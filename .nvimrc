
lua << EOF
-- local cmp = require('cmp')
--
-- local has_words_before = function()
--   local line, col = unpack(vim.api.nvim_win_get_cursor(0))
--   return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match("%s") == nil
-- end
--
-- local feedkey = function(key, mode)
--   vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(key, true, true, true), mode, true)
-- end
--
-- cmp.setup({
-- 	completion = {
-- 		autocomplete = false
-- 	},
-- 	snippet = {
-- 		expand = function (args)
-- 			vim.fn['vsnip#anonymous'](args.body)
-- 		end
-- 	},
-- 	mapping = {
-- 		['<S-Tab>'] = cmp.mapping(function (fallback)
-- 			if cmp.visible() then
-- 				cmp.select_next_item()
-- 			elseif vim.fn['vsnip#available'](1) == 1 then
-- 				feedkey('<Plug>(vsnip-expand-or-jump)', '')
-- 			elseif has_words_before() then
-- 				cmp.complete()
-- 			else
-- 				fallback()
-- 			end
-- 		end, { 'i' }),
-- 		['<Down>'] = { i = cmp.mapping.select_next_item({ behavior = cmp.SelectBehavior.Select }) },
-- 		['<Up>'] = { i = cmp.mapping.select_prev_item({ behavior = cmp.SelectBehavior.Select }) },
-- 		['<ESC>'] = { i = cmp.mapping.abort() },
-- 		['<Space>'] = cmp.mapping(function (fallback)
-- 			if cmp.visible() then
-- 				cmp.mapping.confirm({ select = false })
-- 			else
-- 				fallback()
-- 			end
-- 		end, { 'i' })
-- 	},
-- 	sources = cmp.config.sources({
-- 		{ name = 'nvim_lsp' },
-- 		{ name = 'vsnip' }
-- 	}, {
-- 		{ name = 'buffer' }
-- 	})
-- })
--
-- local capabilities = require('cmp_nvim_lsp').default_capabilities
--
-- local opts = { noremap = true, silent = true }
-- vim.keymap.set('n', 'ge', vim.diagnostic.goto_next, opts)
-- vim.keymap.set('n', 'gE', vim.diagnostic.goto_prev, opts)
-- vim.keymap.set('n', '<C-e>', vim.diagnostic.open_float, opts)
--
-- local onAttach = function(client, bufno)
-- 	local opts = { noremap = true, silent = true, buffer = bufno }
-- 	vim.keymap.set('n', '<C-h>', vim.lsp.buf.hover, opts)
-- 	vim.keymap.set('n', 'gd', vim.lsp.buf.definition, opts)
-- end
--
-- local lspconfig = require('lspconfig')
--
-- lspconfig.tsserver.setup({
-- 	on_attach = onAttach,
-- 	capabilities = capabilities,
-- 		root_dir = function (path)
-- 			local denoPath = lspconfig.util.root_pattern('deno.json', 'deno.jsonc')(path)
-- 			if denoPath then return end
-- 			return lspconfig.util.root_pattern('tsconfig.json')(path)
-- 				or lspconfig.util.root_pattern('package.json', 'jsconfig.json', '.git')(path)
-- 		end,
-- 	settings = {
-- 		typescript = {
-- 			format = {
-- 				enable = false,
-- 				trimTrailingWhitespace = false
-- 			}
-- 		},
-- 		diagnostics = {
-- 			ignoredCodes = {
-- 				2350, -- Only void function can be called with new
-- 				7043, 7044, 7045, 7056, 7047, 7048, 7049, 7050, -- Implicit any warnings
-- 				2365 -- Operator can't be applied to types
-- 			}
-- 		}
-- 	}
-- })
--
-- lspconfig.denols.setup({
-- 	on_attach = onAttach,
-- 	capabilities = capabilities,
-- 	root_dir = lspconfig.util.root_pattern('deno.json', 'deno.jsonc'),
-- 	init_options = {
-- 		enable = true,
-- 		unstable = false,
-- 		lint = false
-- 	}
-- })
--
-- vim.g.markdown_fenced_languages = {
-- 	'ts=typescript'
-- }
--
-- lspconfig.pyright.setup({
-- 	on_attach = onAttach,
-- 	capabilities = capabilities
-- })
--
-- lspconfig.csharp_ls.setup({
-- 	on_attach = onAttach,
-- 	capabilities = capabilities
-- })
--
-- lspconfig.rust_analyzer.setup({
-- 	on_attach = onAttach,
-- 	capabilities = capabilities
-- })
--
-- lspconfig.clangd.setup({
-- 	on_attach = onAttach,
-- 	capabilities = capabilities
-- })
--
-- vim.lsp.handlers['textDocument/publishDiagnostics'] = vim.lsp.with(
-- 	vim.lsp.diagnostic.on_publish_diagnostics, {
-- 		-- delay update diagnostics
-- 		update_in_insert = false,
-- 	}
-- )
EOF